using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Serilog;

namespace MutateCSharp.FileSystem;

public static class FileValidator
{
  public static async Task<SyntaxTree?> GetValidatedSyntaxTree(
    this Document document)
  {
    Log.Debug("Inspecting file: {DocumentPath}", document.FilePath);

    if (document.FilePath is null)
    {
      Log.Debug("{DocumentName} does not exist. Proceeding...", document.Name);
      return null;
    }

    if (Path.GetExtension(document.FilePath) !=
        FileExtension.CSharpSourceFile.ToFriendlyString())
    {
      Log.Debug("{DocumentName} is not a C# source file. Proceeding...",
        document.Name);
      return null;
    }

    if (document.HasGeneratedFileName())
    {
      Log.Debug(
        "Ignoring {DocumentName} as it is automatically generated. Proceeding...",
        document.Name);
      return null;
    }

    if (!document.SupportsSyntaxTree)
    {
      Log.Debug("{DocumentName} does not support syntax tree. Proceeding...",
        document.Name);
      return null;
    }

    var ast = await document.GetSyntaxTreeAsync();

    if (ast is null || !ast.HasCompilationUnitRoot)
    {
      Log.Debug("{DocumentName} does not have compilable syntax. Proceeding...",
        document.Name);
      return null;
    }

    var root = ast.GetCompilationUnitRoot();

    if (root.Members.Count == 0)
    {
      Log.Debug("{DocumentName} has an empty body. Proceeding...",
        document.Name);
      return null;
    }

    if (root.HasGeneratedLeadingTrivia())
    {
      Log.Debug(
        "Ignoring {DocumentName} as it is automatically generated. Proceeding...",
        document.Name);
      return null;
    }

    return ast;
  }

  public static async Task<SemanticModel?> GetValidatedSemanticModel(
    this Document document)
  {
    if (!document.SupportsSemanticModel)
    {
      Log.Debug("{DocumentName} does not support semantic model. Proceeding...",
        document.Name);
      return null;
    }

    var model = await document.GetSemanticModelAsync();

    if (model is null)
      Log.Warning("Failed to build semantic model for the document.");

    return model;
  }

  private static bool HasGeneratedFileName(this TextDocument document)
  {
    return document.FilePath!.StartsWith(
             GeneratedPatterns.AutoGeneratedFilePrefix,
             StringComparison.OrdinalIgnoreCase)
           || GeneratedPatterns.AutoGeneratedFileExtensions.Any(ext =>
             document.FilePath!.EndsWith(ext,
               StringComparison.OrdinalIgnoreCase));
  }

  private static bool HasGeneratedLeadingTrivia(this CompilationUnitSyntax root)
  {
    var firstToken = root.GetFirstToken();
    if (!firstToken.HasLeadingTrivia) return false;

    foreach (var trivia in firstToken.LeadingTrivia)
    {
      if (!trivia.IsKind(SyntaxKind.SingleLineCommentTrivia) &&
          !trivia.IsKind(SyntaxKind.MultiLineCommentTrivia))
        continue;

      var comment = trivia.ToString();

      if (GeneratedPatterns.AutoGeneratedTriviaPatterns
          .Any(pattern => comment.Contains(pattern)))
        return true;
    }

    return false;
  }
}